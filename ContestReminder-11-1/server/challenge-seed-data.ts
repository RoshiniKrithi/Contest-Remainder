// Mock seed data for challenges - to be integrated with database when ready

export const typingChallenges = [
    // JavaScript Challenges
    {
        id: "typing-js-1",
        title: "Array Map Function",
        code: `const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(n => n * 2);\nconsole.log(doubled);`,
        language: "javascript",
        difficulty: "easy",
        lineCount: 3,
    },
    {
        id: "typing-js-2",
        title: "Async/Await Example",
        code: `async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}\n\nfetchData('/api/users').then(console.log);`,
        language: "javascript",
        difficulty: "medium",
        lineCount: 7,
    },
    {
        id: "typing-js-3",
        title: "Class with Methods",
        code: `class Node {\n  constructor(v) {\n    this.val = v;\n    this.next = null;\n  }\n  append(v) {\n    let curr = this;\n    while (curr.next) curr = curr.next;\n    curr.next = new Node(v);\n  }\n}`,
        language: "javascript",
        difficulty: "hard",
        lineCount: 11,
    },
    {
        id: "typing-js-4",
        title: "Object Destructuring",
        code: `const user = { id: 1, name: 'John', email: 'john@example.com' };\nconst { name, email } = user;\nconsole.log(\`User: \${name}, Email: \${email}\`);`,
        language: "javascript",
        difficulty: "easy",
        lineCount: 3,
    },
    {
        id: "typing-js-5",
        title: "Promise with Timeout",
        code: `const wait = (ms) => new Promise(res => setTimeout(res, ms));\n\nwait(2000).then(() => {\n  console.log('Action completed after 2 seconds');\n});`,
        language: "javascript",
        difficulty: "medium",
        lineCount: 5,
    },
    {
        id: "typing-js-6",
        title: "Recursive Factorial",
        code: `function factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5));`,
        language: "javascript",
        difficulty: "medium",
        lineCount: 6,
    },
    {
        id: "typing-js-7",
        title: "HTTP GET Request",
        code: `fetch('https://api.example.com/data')\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));`,
        language: "javascript",
        difficulty: "easy",
        lineCount: 4,
    },
    {
        id: "typing-js-8",
        title: "Event Listener",
        code: `const btn = document.querySelector('#action-btn');\nbtn.addEventListener('click', (e) => {\n  console.log('Button clicked at:', e.timeStamp);\n  alert('Action Triggered!');\n});`,
        language: "javascript",
        difficulty: "easy",
        lineCount: 5,
    },

    // Python Challenges
    {
        id: "typing-py-1",
        title: "List Transformation",
        code: `numbers = [1, 2, 3, 4, 5]\nsquares = [n**2 for n in numbers]\nprint(squares)`,
        language: "python",
        difficulty: "easy",
        lineCount: 3,
    },
    {
        id: "typing-py-2",
        title: "Frequency Count",
        code: `def count_freq(items):\n    freq = {}\n    for item in items:\n        freq[item] = freq.get(item, 0) + 1\n    return freq\n\nprint(count_freq(['a', 'b', 'a', 'c']))`,
        language: "python",
        difficulty: "medium",
        lineCount: 7,
    },
    {
        id: "typing-py-3",
        title: "Binary Search Tree",
        code: `class Node:\n    def __init__(self, v):\n        self.val = v\n        self.left = None\n        self.right = None\n\ndef insert(root, v):\n    if not root: return Node(v)\n    if v < root.val: root.left = insert(root.left, v)\n    else: root.right = insert(root.right, v)\n    return root`,
        language: "python",
        difficulty: "hard",
        lineCount: 11,
    },
    {
        id: "typing-py-4",
        title: "File Operations",
        code: `with open('mission_log.txt', 'w') as f:\n    f.write('Initializing tactical data sync...')\n    f.write('\\nStatus: Operational')\nprint('Log file written successfully')`,
        language: "python",
        difficulty: "easy",
        lineCount: 4,
    },
    {
        id: "typing-py-5",
        title: "Timer Wrapper",
        code: `import time\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = func(*args, **kwargs)\n        print(f'Done in {time.time()-start:.4f}s')\n        return res\n    return wrapper`,
        language: "python",
        difficulty: "medium",
        lineCount: 8,
    },
    {
        id: "typing-py-6",
        title: "HTTP GET Request",
        code: `import requests\n\ntry:\n    res = requests.get('https://api.example.com/data')\n    print(res.json())\nexcept Exception as e:\n    print(f"Error: {e}")`,
        language: "python",
        difficulty: "easy",
        lineCount: 7,
    },
    {
        id: "typing-py-7",
        title: "CSV Parser",
        code: `import csv\n\nwith open('data.csv', mode='r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(f"Row: {row['id']} -> {row['name']}")`,
        language: "python",
        difficulty: "medium",
        lineCount: 6,
    },
    {
        id: "typing-py-8",
        title: "Threaded Task",
        code: `import threading\n\ndef worker():\n    print("Task executed in background")\n\nt = threading.Thread(target=worker)\nt.start()\nt.join()`,
        language: "python",
        difficulty: "medium",
        lineCount: 8,
    },

    // C++ Challenges
    {
        id: "typing-cpp-1",
        title: "List Transformation",
        code: `#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> nums = {1, 2, 3, 4, 5};\n    std::vector<int> squares;\n    for (int n : nums) squares.push_back(n * n);\n    return 0;\n}`,
        language: "cpp",
        difficulty: "easy",
        lineCount: 9,
    },
    {
        id: "typing-cpp-2",
        title: "Frequency Count",
        code: `#include <map>\n#include <vector>\n#include <string>\n\nstd::map<std::string, int> countFreq(std::vector<std::string> items) {\n    std::map<std::string, int> freq;\n    for (const auto& item : items) freq[item]++;\n    return freq;\n}`,
        language: "cpp",
        difficulty: "medium",
        lineCount: 9,
    },
    {
        id: "typing-cpp-3",
        title: "Binary Search Tree",
        code: `struct Node {\n    int val;\n    Node *left, *right;\n    Node(int v) : val(v), left(nullptr), right(nullptr) {}\n};\n\nNode* insert(Node* root, int v) {\n    if (!root) return new Node(v);\n    if (v < root->val) root->left = insert(root->left, v);\n    else root->right = insert(root->right, v);\n    return root;\n}`,
        language: "cpp",
        difficulty: "hard",
        lineCount: 11,
    },
    {
        id: "typing-cpp-4",
        title: "File Operations",
        code: `#include <fstream>\n#include <string>\n\nint main() {\n    std::ofstream out("log.txt");\n    out << "Log initialized...\\n" << "Status: OK";\n    out.close();\n    return 0;\n}`,
        language: "cpp",
        difficulty: "easy",
        lineCount: 9,
    },
    {
        id: "typing-cpp-5",
        title: "Timer Wrapper",
        code: `#include <chrono>\n#include <iostream>\n\ntemplate<typename F>\nvoid timer(F func) {\n    auto s = std::chrono::steady_clock::now();\n    func();\n    auto e = std::chrono::steady_clock::now();\n    std::chrono::duration<double> d = e - s;\n    std::cout << "Done in " << d.count() << "s\\n";\n}`,
        language: "cpp",
        difficulty: "medium",
        lineCount: 11,
    },
    {
        id: "typing-cpp-6",
        title: "HTTP GET Request",
        code: `// Using libcurl for simplicity\n#include <curl/curl.h>\n\nint main() {\n    CURL *curl = curl_easy_init();\n    if(curl) {\n        curl_easy_setopt(curl, CURLOPT_URL, "https://api.example.com");\n        curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n    }\n    return 0;\n}`,
        language: "cpp",
        difficulty: "medium",
        lineCount: 12,
    },
    {
        id: "typing-cpp-7",
        title: "Sort Algorithm",
        code: `#include <algorithm>\n#include <vector>\n\nvoid sortItems(std::vector<int>& v) {\n    std::sort(v.begin(), v.end(), [](int a, int b) {\n        return a > b;\n    });\n}`,
        language: "cpp",
        difficulty: "easy",
        lineCount: 8,
    },
    {
        id: "typing-cpp-8",
        title: "Pointer Manipulation",
        code: `void swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    swap(&x, &y);\n    return 0;\n}`,
        language: "cpp",
        difficulty: "easy",
        lineCount: 10,
    },

    // Java Challenges
    {
        id: "typing-java-1",
        title: "List Transformation",
        code: `import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> squares = nums.stream()\n            .map(n -> n * n)\n            .collect(Collectors.toList());\n    }\n}`,
        language: "java",
        difficulty: "easy",
        lineCount: 11,
    },
    {
        id: "typing-java-2",
        title: "Frequency Count",
        code: `import java.util.*;\n\npublic class Utils {\n    public Map<String, Integer> countFreq(List<String> items) {\n        Map<String, Integer> freq = new HashMap<>();\n        for (String item : items) {\n            freq.put(item, freq.getOrDefault(item, 0) + 1);\n        }\n        return freq;\n    }\n}`,
        language: "java",
        difficulty: "medium",
        lineCount: 11,
    },
    {
        id: "typing-java-3",
        title: "Binary Search Tree",
        code: `class Node {\n    int val;\n    Node left, right;\n    Node(int v) { val = v; }\n}\n\npublic class BST {\n    Node root;\n    void insert(int v) {\n        root = insertRec(root, v);\n    }\n    Node insertRec(Node root, int v) {\n        if (root == null) return new Node(v);\n        if (v < root.val) root.left = insertRec(root.left, v);\n        else root.right = insertRec(root.right, v);\n        return root;\n    }\n}`,
        language: "java",
        difficulty: "hard",
        lineCount: 18,
    },
    {
        id: "typing-java-4",
        title: "File Operations",
        code: `import java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        try (PrintWriter out = new PrintWriter(new FileWriter("log.txt"))) {\n            out.println("Init log...");\n            out.println("Status: ACTIVE");\n        }\n    }\n}`,
        language: "java",
        difficulty: "easy",
        lineCount: 9,
    },
    {
        id: "typing-java-5",
        title: "HTTP GET Request",
        code: `import java.net.http.*;\nimport java.net.URI;\n\npublic class Client {\n    public void fetch() throws Exception {\n        var client = HttpClient.newHttpClient();\n        var req = HttpRequest.newBuilder()\n            .uri(URI.create("https://api.example.com"))\n            .build();\n        client.send(req, HttpResponse.BodyHandlers.ofString());\n    }\n}`,
        language: "java",
        difficulty: "medium",
        lineCount: 10,
    },
    {
        id: "typing-java-6",
        title: "Generic Interface",
        code: `public interface Processor<T> {\n    T process(T input);\n}\n\npublic class Logger implements Processor<String> {\n    public String process(String in) {\n        System.out.println("Logging: " + in);\n        return in.toUpperCase();\n    }\n}`,
        language: "java",
        difficulty: "medium",
        lineCount: 9,
    },
    {
        id: "typing-java-7",
        title: "Singleton Pattern",
        code: `public class Database {\n    private static Database instance;\n    private Database() {}\n    public static Database getInstance() {\n        if (instance == null) instance = new Database();\n        return instance;\n    }\n}`,
        language: "java",
        difficulty: "easy",
        lineCount: 8,
    },
    {
        id: "typing-java-8",
        title: "JDBC Query",
        code: `import java.sql.*;\n\npublic class DBTask {\n    public void query(String sql) throws SQLException {\n        try (var conn = DriverManager.getConnection("url");\n             var stmt = conn.createStatement()) {\n            stmt.executeQuery(sql);\n        }\n    }\n}`,
        language: "java",
        difficulty: "hard",
        lineCount: 9,
    }
];

export const quizQuestions = [
    // Arrays
    {
        id: "quiz-arr-1",
        question: "What is the time complexity of accessing an element in an array by index?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        correctAnswer: 0,
        topic: "arrays",
        difficulty: "easy",
        explanation: "Arrays provide constant-time access to elements by index because they are stored in contiguous memory locations.",
        timeLimit: 30,
    },
    {
        id: "quiz-arr-2",
        question: "What will be the output of this code?",
        codeSnippet: "const arr = [1, 2, 3];\narr.push(4);\narr.pop();\nconsole.log(arr.length);",
        options: ["2", "3", "4", "undefined"],
        correctAnswer: 1,
        topic: "arrays",
        difficulty: "medium",
        explanation: "After push(4), array is [1,2,3,4]. pop() removes 4, leaving [1,2,3] with length 3.",
        timeLimit: 45,
    },
    {
        id: "quiz-arr-3",
        question: "Which operation on a dynamic array (like ArrayList in Java or vector in C++) has an amortized O(1) time complexity?",
        options: ["Insert at beginning", "Insert at end", "Search for an element", "Delete from middle"],
        correctAnswer: 1,
        topic: "arrays",
        difficulty: "easy",
        explanation: "Inserting at the end is usually O(1), but when the capacity is reached, it requires doubling the capacity, leading to amortized O(1) complexity.",
        timeLimit: 30,
    },
    {
        id: "quiz-arr-4",
        question: "In a 2D array matrix[R][C], what is the formula to access matrix[i][j] in a row-major flattened 1D array?",
        options: ["i + j", "i * C + j", "j * R + i", "i * R + j"],
        correctAnswer: 1,
        topic: "arrays",
        difficulty: "medium",
        explanation: "To flatten a 2D array, you skip 'i' full rows (each of size C) and then add the column offset 'j'.",
        timeLimit: 40,
    },
    {
        id: "quiz-arr-5",
        question: "What is the time complexity of finding the maximum element in an unsorted array of size n?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: 2,
        topic: "arrays",
        difficulty: "easy",
        explanation: "To find the maximum in an unsorted array, you must examine every element exactly once, resulting in O(n) complexity.",
        timeLimit: 30,
    },
    {
        id: "quiz-arr-6",
        question: "Which of these is NOT a characteristic of a static array?",
        options: ["Fixed size", "Contiguous memory", "Random access", "Automatic resizing"],
        correctAnswer: 3,
        topic: "arrays",
        difficulty: "easy",
        explanation: "Static arrays have a fixed size upon creation. Dynamic arrays (like ArrayList) provide automatic resizing.",
        timeLimit: 25,
    },
    {
        id: "quiz-arr-7",
        question: "What is the space complexity of an in-place array reversal algorithm?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: 0,
        topic: "arrays",
        difficulty: "easy",
        explanation: "An in-place reversal only uses a constant amount of extra space (like a temporary variable for swapping).",
        timeLimit: 30,
    },
    {
        id: "quiz-arr-8",
        question: "In a circular array of size N, if the current index is 'i', what is the index of the next element?",
        options: ["i + 1", "(i + 1) * N", "(i + 1) % N", "i % (N + 1)"],
        correctAnswer: 2,
        topic: "arrays",
        difficulty: "medium",
        explanation: "The modulo operator (%) ensures that when i + 1 reach N, it wraps back to 0.",
        timeLimit: 35,
    },
    {
        id: "quiz-arr-9",
        question: "Which data structure is typically used to implement a 'Stack' using an array?",
        options: ["Dynamic Array", "2D Array", "Sparse Array", "Bit Array"],
        correctAnswer: 0,
        topic: "arrays",
        difficulty: "medium",
        explanation: "A dynamic array allows for efficient pushing and popping from the end, which are the primary operations of a stack.",
        timeLimit: 40,
    },
    {
        id: "quiz-arr-10",
        question: "What happens if you try to access an index 'n' in an array of size 'n' in C++ or Java?",
        options: ["It returns the first element", "It returns null", "It causes an IndexOutOfBounds exception or undefined behavior", "It automatically expands the array"],
        correctAnswer: 2,
        topic: "arrays",
        difficulty: "easy",
        explanation: "Arrays are zero-indexed, so the valid indices for an array of size 'n' are 0 to n-1. Index 'n' is out of bounds.",
        timeLimit: 30,
    },

    // Strings
    {
        id: "quiz-str-1",
        question: "What is the time complexity of concatenating n strings of length m using the + operator in most languages?",
        options: ["O(n)", "O(m)", "O(nm)", "O(n²m)"],
        correctAnswer: 3,
        topic: "strings",
        difficulty: "medium",
        explanation: "Each concatenation creates a new string and copies all previous characters, leading to O(n²m) complexity.",
        timeLimit: 50,
    },
    {
        id: "quiz-str-2",
        question: "Which algorithm is commonly used for pattern matching in strings?",
        options: ["Binary Search", "KMP Algorithm", "Merge Sort", "Dijkstra's Algorithm"],
        correctAnswer: 1,
        topic: "strings",
        difficulty: "medium",
        explanation: "The Knuth-Morris-Pratt (KMP) algorithm efficiently finds pattern occurrences in strings.",
        timeLimit: 45,
    },
    {
        id: "quiz-str-3",
        question: "What is the space complexity of creating a suffix tree for a string of length n?",
        options: ["O(log n)", "O(n)", "O(n²)", "O(2^n)"],
        correctAnswer: 1,
        topic: "strings",
        difficulty: "hard",
        explanation: "Ukkonen's algorithm creates a suffix tree in O(n) time and O(n) space.",
        timeLimit: 60,
    },
    {
        id: "quiz-str-4",
        question: "In JavaScript, are strings primitive and immutable?",
        options: ["Yes", "No, they are mutable", "They are objects", "Only in strict mode"],
        correctAnswer: 0,
        topic: "strings",
        difficulty: "easy",
        explanation: "Strings in JavaScript are immutable primitives; any 'change' results in a new string.",
        timeLimit: 25,
    },
    {
        id: "quiz-str-5",
        question: "What is the time complexity of checking if a string of length n is a palindrome?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: 2,
        topic: "strings",
        difficulty: "easy",
        explanation: "You need to compare characters from both ends towards the middle, visiting each character at most once.",
        timeLimit: 30,
    },
    {
        id: "quiz-str-6",
        question: "Which string data structure is most efficient for performing multiple modifications (like insertions or deletions)?",
        options: ["String", "StringBuilder", "StringBuffer", "Char Array"],
        correctAnswer: 1,
        topic: "strings",
        difficulty: "medium",
        explanation: "StringBuilder (in Java/C#) is designed for efficient string mutations without creating many intermediate string objects.",
        timeLimit: 35,
    },
    {
        id: "quiz-str-7",
        question: "In the ASCII standard, how many bits are used to represent a single character?",
        options: ["7 bits", "8 bits", "16 bits", "32 bits"],
        correctAnswer: 0,
        topic: "strings",
        difficulty: "easy",
        explanation: "Standard ASCII uses 7 bits, providing 128 unique character codes. Extended ASCII uses 8 bits.",
        timeLimit: 30,
    },
    {
        id: "quiz-str-8",
        question: "The 'Trie' data structure is also known as a:",
        options: ["Suffix Tree", "Prefix Tree", "B-Tree", "Segment Tree"],
        correctAnswer: 1,
        topic: "strings",
        difficulty: "medium",
        explanation: "A Trie or Prefix Tree is used to store a dynamic set of strings, where keys are usually strings sharing prefixes.",
        timeLimit: 40,
    },
    {
        id: "quiz-str-9",
        question: "Which of these is a 'Lossy' compression algorithm often used for images but not usually for text strings?",
        options: ["Huffman Coding", "LZW", "JPEG", "RLE"],
        correctAnswer: 2,
        topic: "strings",
        difficulty: "medium",
        explanation: "JPEG is lossy. String compression (like zip/gzip) must be lossless (like Huffman or LZW) to preserve original data.",
        timeLimit: 45,
    },
    {
        id: "quiz-str-10",
        question: "What does the 'Big-O' complexity O(n*m) represent in string search where n is text length and m is pattern length?",
        options: ["Boyer-Moore best case", "KMP average case", "Brute-force worst case", "Rabin-Karp best case"],
        correctAnswer: 2,
        topic: "strings",
        difficulty: "medium",
        explanation: "Simple brute-force string matching can take O(n*m) if we reset the pattern pointer for every text character.",
        timeLimit: 45,
    },

    // Linked Lists
    {
        id: "quiz-ll-1",
        question: "What is the time complexity of deleting a node at the beginning of a singly linked list?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: 0,
        topic: "linkedlists",
        difficulty: "easy",
        explanation: "Deleting from the front only requires updating the 'head' pointer, which is a constant time operation.",
        timeLimit: 30,
    },
    {
        id: "quiz-ll-2",
        question: "Which algorithm can detect a cycle in a linked list using O(1) space?",
        options: ["Dijkstra's", "Floyd's Cycle-Finding Algorithm", "Binary Search", "Kruskal's"],
        correctAnswer: 1,
        topic: "linkedlists",
        difficulty: "medium",
        explanation: "Floyd's 'Tortoise and Hare' algorithm use two pointers moving at different speeds to detect cycles.",
        timeLimit: 40,
    },
    {
        id: "quiz-ll-3",
        question: "What is the worst-case time complexity to find the k-th element from the end of a singly linked list?",
        options: ["O(1)", "O(k)", "O(n)", "O(n log n)"],
        correctAnswer: 2,
        topic: "linkedlists",
        difficulty: "medium",
        explanation: "You must traverse at least a portion of the list, potentially the whole list in one or two passes.",
        timeLimit: 40,
    },
    {
        id: "quiz-ll-4",
        question: "What is the primary advantage of a doubly linked list over a singly linked list?",
        options: ["Less memory usage", "Faster traversal in both directions", "Faster insertion at the beginning", "Simpler implementation"],
        correctAnswer: 1,
        topic: "linkedlists",
        difficulty: "easy",
        explanation: "A doubly linked list stores pointers to both next and previous nodes, allowing bidirectional traversal.",
        timeLimit: 30,
    },
    {
        id: "quiz-ll-5",
        question: "What is the time complexity of reversing a singly linked list of size n?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: 2,
        topic: "linkedlists",
        difficulty: "easy",
        explanation: "Reversing a linked list requires a single pass over all nodes, hence O(n).",
        timeLimit: 35,
    },
    {
        id: "quiz-ll-6",
        question: "In a circular linked list, where does the 'next' pointer of the last node point to?",
        options: ["Null", "The head node", "The second node", "Back to itself"],
        correctAnswer: 1,
        topic: "linkedlists",
        difficulty: "easy",
        explanation: "In a circular linked list, the last node links back to the head node to form a circle.",
        timeLimit: 25,
    },
    {
        id: "quiz-ll-7",
        question: "Which of these is NOT true about Skip Lists?",
        options: ["They are balanced trees", "They are probabilistic data structures", "They use multiple layers of linked lists", "Search time is O(log n)"],
        correctAnswer: 0,
        topic: "linkedlists",
        difficulty: "hard",
        explanation: "Skip Lists are based on linked lists, not trees, although they share similar search complexities.",
        timeLimit: 50,
    },
    {
        id: "quiz-ll-8",
        question: "To delete a node 'P' in a singly linked list given only a pointer to 'P' (not the head), what is the common trick?",
        options: ["Traverse from head to P", "Copy data from P.next to P and delete P.next", "It's impossible", "Set P to null"],
        correctAnswer: 1,
        topic: "linkedlists",
        difficulty: "medium",
        explanation: "You copy the value from the next node into the current node and then remove the next node.",
        timeLimit: 45,
    },
    {
        id: "quiz-ll-9",
        question: "What is the time complexity to find the middle of a linked list in one pass?",
        options: ["O(1)", "O(n/2)", "O(n)", "O(log n)"],
        correctAnswer: 2,
        topic: "linkedlists",
        difficulty: "easy",
        explanation: "Using two pointers (slow and fast), you find the middle in O(n) time.",
        timeLimit: 30,
    },
    {
        id: "quiz-ll-10",
        question: "Which data structure is essentially a linked list where each node can have pointers to multiple other nodes?",
        options: ["Binary Tree", "Stack", "Queue", "Graph"],
        correctAnswer: 3,
        topic: "linkedlists",
        difficulty: "medium",
        explanation: "A graph is a generalized version where nodes (vertices) can connect to any number of other nodes.",
        timeLimit: 30,
    },

    // Trees
    {
        id: "quiz-tree-1",
        question: "In a binary search tree, where is the minimum value located?",
        options: ["Root", "Leftmost node", "Rightmost node", "Any leaf node"],
        correctAnswer: 1,
        topic: "trees",
        difficulty: "easy",
        explanation: "In a BST, smaller values are to the left, so the minimum is at the leftmost node.",
        timeLimit: 30,
    },
    {
        id: "quiz-tree-2",
        question: "What is the height of a balanced binary tree with n nodes?",
        options: ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
        correctAnswer: 1,
        topic: "trees",
        difficulty: "medium",
        explanation: "A balanced binary tree has O(log n) height, which is why operations are efficient.",
        timeLimit: 40,
    },
    {
        id: "quiz-tree-3",
        question: "Which traversal of a BST produces elements in sorted order?",
        options: ["Pre-order", "In-order", "Post-order", "Level-order"],
        correctAnswer: 1,
        topic: "trees",
        difficulty: "easy",
        explanation: "In-order traversal visits nodes in the order Left -> Root -> Right, which is the sorted order for a BST.",
        timeLimit: 30,
    },
    {
        id: "quiz-tree-4",
        question: "What is the maximum number of nodes in a full binary tree of height h?",
        options: ["2*h", "2^h", "2^(h+1) - 1", "2^h - 1"],
        correctAnswer: 2,
        topic: "trees",
        difficulty: "medium",
        explanation: "A tree of height h has 2^(h+1)-1 nodes if we consider the root at height 0.",
        timeLimit: 45,
    },
    {
        id: "quiz-tree-5",
        question: "Which of the following is NOT a self-balancing binary search tree?",
        options: ["AVL Tree", "Red-Black Tree", "Heap", "Splay Tree"],
        correctAnswer: 2,
        topic: "trees",
        difficulty: "easy",
        explanation: "A Heap is not primarily a search tree; it's used for priority queues and keeping track of min/max values.",
        timeLimit: 30,
    },
    {
        id: "quiz-tree-6",
        question: "What is the worst-case time complexity of searching in an unbalanced Binary Search Tree?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        correctAnswer: 2,
        topic: "trees",
        difficulty: "medium",
        explanation: "An unbalanced BST can degenerate into a linked list, making search O(n).",
        timeLimit: 35,
    },
    {
        id: "quiz-tree-7",
        question: "Which tree traversal is equivalent to Breadth-First Search (BFS)?",
        options: ["In-order", "Pre-order", "Post-order", "Level-order"],
        correctAnswer: 3,
        topic: "trees",
        difficulty: "easy",
        explanation: "Level-order traversal visits nodes level by level, which is exactly how BFS works on trees.",
        timeLimit: 25,
    },
    {
        id: "quiz-tree-8",
        question: "In a Max Heap, where is the largest element always found?",
        options: ["Root", "Any leaf node", "Left child of root", "Rightmost leaf"],
        correctAnswer: 0,
        topic: "trees",
        difficulty: "easy",
        explanation: "The defining property of a Max Heap is that every node is greater than or equal to its children.",
        timeLimit: 25,
    },
    {
        id: "quiz-tree-9",
        question: "What is the balance factor of a node in an AVL tree?",
        options: ["Height(L) + Height(R)", "Height(L) - Height(R)", "Max(Height(L), Height(R))", "Height(L) * Height(R)"],
        correctAnswer: 1,
        topic: "trees",
        difficulty: "medium",
        explanation: "The balance factor is the difference between heights of left and right subtrees (must be -1, 0, or 1).",
        timeLimit: 40,
    },
    {
        id: "quiz-tree-10",
        question: "Which data structure is best for implementing an 'Autocomplete' or 'Dictionary' feature?",
        options: ["Splay Tree", "B-Tree", "Trie", "Binary Heap"],
        correctAnswer: 2,
        topic: "trees",
        difficulty: "medium",
        explanation: "A Trie (Prefix Tree) is highly efficient for prefix-based searches and string keys.",
        timeLimit: 40,
    },

    // Graphs
    // Graphs
    {
        id: "quiz-graph-1",
        question: "Which graph traversal uses a queue data structure?",
        options: ["Depth-First Search (DFS)", "Breadth-First Search (BFS)", "Dijkstra's Algorithm", "Prim's Algorithm"],
        correctAnswer: 1,
        topic: "graphs",
        difficulty: "medium",
        explanation: "BFS uses a queue to explore nodes level by level, while DFS uses a stack (or recursion).",
        timeLimit: 40,
    },
    {
        id: "quiz-graph-2",
        question: "What is the maximum number of edges in a simple undirected graph with n vertices?",
        options: ["n", "n(n-1)", "n(n-1)/2", "2^n"],
        correctAnswer: 2,
        topic: "graphs",
        difficulty: "hard",
        explanation: "In a complete simple undirected graph, each vertex connects to n-1 others, but each edge is counted twice, so it's n(n-1)/2.",
        timeLimit: 60,
    },
    {
        id: "quiz-graph-3",
        question: "Which algorithm finds the shortest path in a weighted graph with no negative edges?",
        options: ["BFS", "Prim's", "Dijkstra's", "Kruskal's"],
        correctAnswer: 2,
        topic: "graphs",
        difficulty: "medium",
        explanation: "Dijkstra's algorithm is the standard choice for shortest paths in graphs with non-negative edge weights.",
        timeLimit: 45,
    },
    {
        id: "quiz-graph-4",
        question: "What is a 'DAG' in graph theory?",
        options: ["Directed Acyclic Graph", "Direct Application Graph", "Disconnected Acyclic Graph", "Data Access Graph"],
        correctAnswer: 0,
        topic: "graphs",
        difficulty: "easy",
        explanation: "DAG stands for Directed Acyclic Graph, a directed graph with no directed cycles.",
        timeLimit: 30,
    },
    {
        id: "quiz-graph-5",
        question: "Which algorithm is used to find the Minimum Spanning Tree of a graph?",
        options: ["Kruskal's", "Bellman-Ford", "Floyd-Warshall", "A* Search"],
        correctAnswer: 0,
        topic: "graphs",
        difficulty: "medium",
        explanation: "Kruskal's and Prim's are both used to find MSTs. Kruskal's uses a greedy approach and Disjoint Set Union.",
        timeLimit: 40,
    },
    {
        id: "quiz-graph-6",
        question: "Which algorithm can find shortest paths in a graph containing negative edge weights (provided no negative cycles)?",
        options: ["Dijkstra's", "Bellman-Ford", "BFS", "Greedy Search"],
        correctAnswer: 1,
        topic: "graphs",
        difficulty: "medium",
        explanation: "Bellman-Ford can handle negative weights, unlike Dijkstra's.",
        timeLimit: 45,
    },
    {
        id: "quiz-graph-7",
        question: "What is the time complexity of a BFS on a graph with V vertices and E edges using an adjacency list?",
        options: ["O(V)", "O(E)", "O(V + E)", "O(V * E)"],
        correctAnswer: 2,
        topic: "graphs",
        difficulty: "medium",
        explanation: "BFS visits every vertex and every edge exactly once in an adjacency list representation.",
        timeLimit: 35,
    },
    {
        id: "quiz-graph-8",
        question: "In a 'Bipartite Graph', vertices can be divided into how many independent sets?",
        options: ["1", "2", "3", "Any Number"],
        correctAnswer: 1,
        topic: "graphs",
        difficulty: "easy",
        explanation: "A bipartite graph's vertices can be split into two sets such that no two vertices within the same set are connected.",
        timeLimit: 30,
    },
    {
        id: "quiz-graph-9",
        question: "Which of these is NOT a representation of a graph?",
        options: ["Adjacency Matrix", "Adjacency List", "Edge List", "Circular Queue"],
        correctAnswer: 3,
        topic: "graphs",
        difficulty: "easy",
        explanation: "Adjacency Matrix/List and Edge List are standard ways to represent graph topology.",
        timeLimit: 25,
    },
    {
        id: "quiz-graph-10",
        question: "What identifies a cycle in a directed graph using DFS?",
        options: ["A node with degree 0", "A 'Back Edge' to an ancestor in the recursion stack", "A node with no children", "Total edges > vertices"],
        correctAnswer: 1,
        topic: "graphs",
        difficulty: "hard",
        explanation: "If you encounter a node that is already in the current recursion stack during DFS, a cycle exists.",
        timeLimit: 50,
    },

    // Dynamic Programming
    {
        id: "quiz-dp-1",
        question: "What is the main idea behind dynamic programming?",
        options: [
            "Divide and conquer",
            "Storing results of subproblems to avoid recomputation",
            "Using greedy choices",
            "Randomization"
        ],
        correctAnswer: 1,
        topic: "dp",
        difficulty: "easy",
        explanation: "Dynamic programming stores solutions to subproblems (memoization or tabulation) to avoid redundant calculations.",
        timeLimit: 35,
    },
    {
        id: "quiz-dp-2",
        question: "Which approach is typically faster for the Fibonacci sequence with memoization?",
        options: ["Top-down", "Bottom-up", "Both are equal", "Neither uses memoization"],
        correctAnswer: 1,
        topic: "dp",
        difficulty: "medium",
        explanation: "Bottom-up (tabulation) often has slightly better performance due to avoiding recursion overhead.",
        timeLimit: 30,
    },
    {
        id: "quiz-dp-3",
        question: "The 'Knapsack Problem' is a classic example of:",
        options: ["Greedy algorithm", "Dynamic Programming", "Graph Traversal", "Sorting"],
        correctAnswer: 1,
        topic: "dp",
        difficulty: "easy",
        explanation: "The 0/1 Knapsack problem is solve efficiently using DP to explore all possible weight combinations.",
        timeLimit: 30,
    },
    {
        id: "quiz-dp-4",
        question: "What does 'Memoization' refer to in DP?",
        options: ["Iterative approach", "Recursive approach with a cache", "Sorting data", "Optimizing memory usage"],
        correctAnswer: 1,
        topic: "dp",
        difficulty: "easy",
        explanation: "Memoization is the top-down DP approach where you cache results of recursive calls.",
        timeLimit: 25,
    },
    {
        id: "quiz-dp-5",
        question: "What is the time complexity of the classic Longest Common Subsequence (LCS) problem for two strings of length m and n?",
        options: ["O(m+n)", "O(m*n)", "O(2^n)", "O(m^n)"],
        correctAnswer: 1,
        topic: "dp",
        difficulty: "medium",
        explanation: "LCS uses a 2D table of size (m+1) x (n+1), filling each cell in O(1) time.",
        timeLimit: 40,
    },
    {
        id: "quiz-dp-6",
        question: "DP is applicable when the problem has which two properties?",
        options: ["Sorting and searching", "Greedy and random", "Optimal substructure and overlapping subproblems", "Large data and small memory"],
        correctAnswer: 2,
        topic: "dp",
        difficulty: "hard",
        explanation: "To use DP, the problem must exhibit optimal substructure and contain subproblems that repeat multiple times.",
        timeLimit: 45,
    },
    {
        id: "quiz-dp-7",
        question: "Which of these is NOT a classic DP problem?",
        options: ["Coin Change", "Edit Distance", "Matrix Chain Multiplication", "Bubble Sort"],
        correctAnswer: 3,
        topic: "dp",
        difficulty: "easy",
        explanation: "Bubble Sort is a simple comparison sort, not a dynamic programming problem.",
        timeLimit: 25,
    },
    {
        id: "quiz-dp-8",
        question: "What is the time complexity of the 0/1 Knapsack problem given N items and capacity W?",
        options: ["O(2^N)", "O(N*W)", "O(N+W)", "O(N^2)"],
        correctAnswer: 1,
        topic: "dp",
        difficulty: "medium",
        explanation: "The DP table has N rows and W columns, leading to O(N*W) complexity.",
        timeLimit: 40,
    },
    {
        id: "quiz-dp-9",
        question: "Does DP always find the global optimum for problems with optimal substructure?",
        options: ["Yes", "No", "Only for sorting", "Only for small N"],
        correctAnswer: 0,
        topic: "dp",
        difficulty: "medium",
        explanation: "If a problem has optimal substructure, DP is guaranteed to find the absolute optimal solution by exploring the state space efficiently.",
        timeLimit: 30,
    },
    {
        id: "quiz-dp-10",
        question: "Which data structure is primarily used for Tabulation in DP?",
        options: ["Stack", "Queue", "Table (Array/Matrix)", "Linked List"],
        correctAnswer: 2,
        topic: "dp",
        difficulty: "easy",
        explanation: "Tabulation (bottom-up) fills an array or matrix systematically.",
        timeLimit: 25,
    },

    // Sorting & Searching
    {
        id: "quiz-sort-1",
        question: "What is the average time complexity of Quick Sort?",
        options: ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
        correctAnswer: 1,
        topic: "sorting",
        difficulty: "medium",
        explanation: "Quick Sort has an average-case performance of O(n log n), although the worst-case is O(n²).",
        timeLimit: 40,
    },
    {
        id: "quiz-sort-2",
        question: "Which of the following sorting algorithms is stable by default?",
        options: ["Quick Sort", "Heap Sort", "Merge Sort", "Selection Sort"],
        correctAnswer: 2,
        topic: "sorting",
        difficulty: "easy",
        explanation: "Merge Sort is a stable sort, meaning it preserves the relative order of equal elements.",
        timeLimit: 40,
    },
    {
        id: "quiz-sort-3",
        question: "What is the minimum number of comparisons needed to find an element in a sorted array of size n?",
        options: ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
        correctAnswer: 1,
        topic: "sorting",
        difficulty: "easy",
        explanation: "Binary search allows finding an element in O(log n) comparisons in a sorted array.",
        timeLimit: 30,
    },
    {
        id: "quiz-sort-4",
        question: "What is the space complexity of MergeSort?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
        correctAnswer: 2,
        topic: "sorting",
        difficulty: "medium",
        explanation: "MergeSort requires an auxiliary array of size n to merge the sorted halves.",
        timeLimit: 35,
    },
    {
        id: "quiz-sort-5",
        question: "Which sort is generally fastest for small arrays (less than 10-20 elements)?",
        options: ["MergeSort", "QuickSort", "Insertion Sort", "HeapSort"],
        correctAnswer: 2,
        topic: "sorting",
        difficulty: "easy",
        explanation: "Insertion Sort has very low constant overhead and is extremely fast for very small datasets.",
        timeLimit: 25,
    },
    {
        id: "quiz-sort-6",
        question: "What is the worst-case complexity of Binary Search?",
        options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        correctAnswer: 1,
        topic: "sorting",
        difficulty: "easy",
        explanation: "Binary search repeatedly divides the array into half, taking at most log2(n) steps.",
        timeLimit: 25,
    },
    {
        id: "quiz-sort-7",
        question: "Which sorting algorithm based on comparison has a worst-case O(n log n) time complexity?",
        options: ["QuickSort", "MergeSort", "Bubble Sort", "Insertion Sort"],
        correctAnswer: 1,
        topic: "sorting",
        difficulty: "medium",
        explanation: "MergeSort and HeapSort are guaranteed O(n log n), while QuickSort can degrade to O(n²).",
        timeLimit: 30,
    },
    {
        id: "quiz-sort-8",
        question: "What is the time complexity of an optimal randomized search for a key in a sorted array?",
        options: ["O(1)", "O(log n)", "O(n)", "O(1.5 log n)"],
        correctAnswer: 1,
        topic: "sorting",
        difficulty: "easy",
        explanation: "Even with randomization, the information theory lower bound for searching in a sorted array is O(log n).",
        timeLimit: 30,
    },
    {
        id: "quiz-sort-9",
        question: "Counting Sort and Radix Sort are examples of:",
        options: ["Comparison sorts", "Non-comparison sorts", "Divide and conquer", "Greedy sorts"],
        correctAnswer: 1,
        topic: "sorting",
        difficulty: "hard",
        explanation: "These algorithms use properties of the data (like digit value) rather than direct comparisons between elements.",
        timeLimit: 45,
    },
    {
        id: "quiz-sort-10",
        question: "Which sorting algorithm is often used in the C++ STL 'sort' function (intro-sort)?",
        options: ["Only QuickSort", "Only MergeSort", "QuickSort, HeapSort, and Insertion Sort", "Bubble Sort"],
        correctAnswer: 2,
        topic: "sorting",
        difficulty: "hard",
        explanation: "Intro-sort begins with QuickSort, switches to HeapSort if recursion depth is too high, and finishes with Insertion Sort.",
        timeLimit: 50,
    },

    // Greedy Algorithms
    {
        id: "quiz-greedy-1",
        question: "What is a characteristic of greedy algorithms?",
        options: [
            "They always find the global optimum",
            "They make the best local choice at each step",
            "They use backtracking",
            "They explore all possible solutions"
        ],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "easy",
        explanation: "Greedy algorithms make the locally optimal choice at each step with the hope of finding a global optimum.",
        timeLimit: 30,
    },
    {
        id: "quiz-greedy-2",
        question: "Which algorithm for finding a Minimum Spanning Tree is greedy?",
        options: ["Dijkstra's", "Kruskal's", "Floyd-Warshall", "Bellman-Ford"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "medium",
        explanation: "Both Kruskal's and Prim's algorithms are greedy strategies for finding an MST.",
        timeLimit: 45,
    },
    {
        id: "quiz-greedy-3",
        question: "Does a greedy algorithm always find the global optimum?",
        options: ["Yes", "No", "Only for sorting", "Only if data is small"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "easy",
        explanation: "Greedy algorithms are fast but don't always work if the problem lacks the greedy-choice property (like 0/1 Knapsack).",
        timeLimit: 30,
    },
    {
        id: "quiz-greedy-4",
        question: "Which of the following is solved correctly by a greedy algorithm?",
        options: ["0/1 Knapsack", "Fractional Knapsack", "Traveling Salesman Problem", "Longest Path Problem"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "medium",
        explanation: "Fractional Knapsack can be solved greedily by picking items with the highest value-to-weight ratio.",
        timeLimit: 40,
    },
    {
        id: "quiz-greedy-5",
        question: "Huffman Coding uses a greedy strategy to build:",
        options: ["An optimal prefix tree", "A balanced search tree", "A shortest path", "A sorted array"],
        correctAnswer: 0,
        topic: "greedy",
        difficulty: "medium",
        explanation: "Huffman coding greedily merges the two least frequent nodes to create a minimal length encoding tree.",
        timeLimit: 35,
    },
    {
        id: "quiz-greedy-6",
        question: "Primm's and Kruskal's for Minimum Spanning Tree are examples of:",
        options: ["DP", "Greedy Algorithms", "Randomized Algorithms", "Linear Programming"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "medium",
        explanation: "Both algorithms greedily pick the next 'cheapest' edge that doesn't form a cycle.",
        timeLimit: 35,
    },
    {
        id: "quiz-greedy-7",
        question: "In the Coin Change problem, the greedy approach works for which set of denominations?",
        options: ["{1, 3, 4}", "{1, 5, 10, 25}", "{2, 5, 8}", "It always works"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "hard",
        explanation: "Greedy coin change works for 'canonical' systems like USD, but fails for arbitrary sets (e.g. 6 cents from {1,3,4} gives 4+1+1=3 coins instead of 3+3=2).",
        timeLimit: 45,
    },
    {
        id: "quiz-greedy-8",
        question: "What is the time complexity of Kruskal's algorithm (using sorting and DSU)?",
        options: ["O(V log V)", "O(E log E)", "O(E V)", "O(E + V)"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "medium",
        explanation: "Sorting the E edges takes O(E log E), and DSU operations are nearly constant time.",
        timeLimit: 40,
    },
    {
        id: "quiz-greedy-9",
        question: "Which property is essential for a problem to be solvable by a greedy algorithm?",
        options: ["Overlapping subproblems", "Greedy-choice property and Optimal substructure", "LIFO property", "Large memory"],
        correctAnswer: 1,
        topic: "greedy",
        difficulty: "hard",
        explanation: "A problem must allow for local optimal choices to lead to a global optimum for Greedy to work.",
        timeLimit: 45,
    },
    {
        id: "quiz-greedy-10",
        question: "Does Dijkstra's algorithm use a greedy approach?",
        options: ["Yes", "No", "Only for graphs with cycles", "Only if count > 10"],
        correctAnswer: 0,
        topic: "greedy",
        difficulty: "easy",
        explanation: "Dijkstra's is greedy because it always picks the nearest unvisited vertex.",
        timeLimit: 30,
    },
];

export const brainTeasers = [
    {
        id: "teaser-1",
        date: new Date().toISOString(),
        title: "The Two Egg Problem",
        puzzle: "You have two identical eggs and access to a 100-floor building. You want to find the highest floor from which an egg can be dropped without breaking. What is the minimum number of drops required in the worst case to guarantee you find this floor?",
        hint1: "Think about how to minimize the worst-case number of drops, not the average case.",
        hint2: "Consider starting from a floor that isn't too high or too low, and adjust your strategy based on whether the first egg breaks.",
        hint3: "The optimal strategy involves dropping from floor 14 first, then adjusting by decreasing intervals.",
        solution: "14",
        difficulty: "hard",
        explanation: "Start at floor 14. If it breaks, test floors 1-13 linearly (13 more drops max). If it doesn't break, go to floor 27 (14+13), then 39 (27+12), etc. This minimizes worst-case drops to 14.",
        category: "logic",
    },
    {
        id: "teaser-2",
        date: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
        title: "Missing Number",
        puzzle: "An array contains numbers from 1 to 100, but one number is missing. What's the fastest way to find the missing number?",
        hint1: "Think about mathematical properties of sequences.",
        hint2: "The sum of numbers from 1 to n has a formula: n(n+1)/2",
        hint3: "Calculate the expected sum and subtract the actual sum.",
        solution: "sum formula",
        difficulty: "easy",
        explanation: "Calculate the expected sum using n(n+1)/2 for n=100, which is 5050. Subtract the sum of array elements. The difference is the missing number. Time: O(n), Space: O(1).",
        category: "math",
    },
    {
        id: "teaser-3",
        date: new Date(Date.now() + 2 * 86400000).toISOString(), // Day after tomorrow
        title: "Clock Angle",
        puzzle: "At what time between 3 and 4 o'clock are the hour and minute hands of a clock exactly opposite to each other (180 degrees apart)?",
        hint1: "The minute hand moves 360° in 60 minutes (6° per minute).",
        hint2: "The hour hand moves 30° per hour (0.5° per minute).",
        hint3: "Set up an equation where the angle difference equals 180°.",
        solution: "3:49:05",
        difficulty: "medium",
        explanation: "At time 3:x, the hour hand is at 90 + 0.5x degrees, minute hand at 6x degrees. For 180° difference: |6x - (90 + 0.5x)| = 180. Solving gives x ≈ 49.09 minutes = 3:49:05.",
        category: "math",
    },
];

